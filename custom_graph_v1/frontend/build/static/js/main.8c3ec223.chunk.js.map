{"version":3,"sources":["Main.jsx","index.tsx"],"names":["CanvasJSChart","CanvasJSReact","CanvasJS","dataPoints","toastr","options","positionClass","hideDuration","timeOut","App","Component","constructor","props","super","this","updateChart","bind","toggleDataSeries","componentDidMount","kwargs","args","refresh_sec","Streamlit","setFrameHeight","setInterval","e","dataSeries","visible","chart","render","chartType","state","newChartType","setState","formattedData","data","map","item","x","Date","timestamp_est","y","open","high","low","close","type","api","console","log","res","axios","post","JSON","parse","x_axis","y_axis","refresh_button","theme_options","fetchGraphData","newSeries","axis","y_index","row","index","length","indexLabel","toFixed","indexLabelFontColor","pop","push","legendText","forEach","series","success","error","concat","message","colorSet","y_max","dataY","xValueFormatString","yValueFormatString","showInLegend","name","addColorSet","backgroundColor","zoomEnabled","title","text","axisX","labelFormatter","moment","value","format","labelFontSize","axisY","suffix","maximum","gridColor","toolTip","shared","contentFormatter","content","formattedXValue","entries","dataPoint","i","entry","color","legend","cursor","verticalAlign","fontSize","fontColor","itemclick","height","graph_height","React","createElement","style","display","margin","className","onClick","onRef","ref","withStreamlitConnection","ReactDOM","StrictMode","Main","document","getElementById"],"mappings":"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","file":"static/js/main.8c3ec223.chunk.js","sourcesContent":["import React, { Component } from \"react\"\r\nimport CanvasJSReact from \"@canvasjs/react-charts\"\r\nimport moment from \"moment\"\r\n\r\nimport {\r\n  Streamlit,\r\n  withStreamlitConnection,\r\n} from \"streamlit-component-lib\"\r\n\r\nimport toastr from \"toastr\"\r\nimport \"toastr/build/toastr.min.css\"\r\n\r\nimport axios from \"axios\"\r\n\r\nvar CanvasJSChart = CanvasJSReact.CanvasJSChart\r\nvar CanvasJS = CanvasJSReact.CanvasJS\r\nconst dataPoints = [[], [], [], [], [], [], [], [], [], []]\r\n\r\ntoastr.options = {\r\n  positionClass: \"toast-top-full-width\",\r\n  hideDuration: 300,\r\n  timeOut: 3000,\r\n}\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.updateChart = this.updateChart.bind(this)\r\n    this.toggleDataSeries = this.toggleDataSeries.bind(this)\r\n  }\r\n  componentDidMount() {\r\n    const { kwargs } = this.props.args\r\n    const { refresh_sec } = kwargs\r\n    Streamlit.setFrameHeight()\r\n    this.updateChart()\r\n    if (refresh_sec) setInterval(this.updateChart, refresh_sec * 1000)\r\n  }\r\n  toggleDataSeries(e) {\r\n    if (typeof e.dataSeries.visible === \"undefined\" || e.dataSeries.visible) {\r\n      e.dataSeries.visible = false\r\n    } else {\r\n      e.dataSeries.visible = true\r\n    }\r\n    this.chart.render()\r\n  }\r\n  toggleDataSeries() {\r\n    const { chartType } = this.state;\r\n    const newChartType = chartType === \"spline\" ? \"candlestick\" : \"spline\";\r\n    this.setState({ chartType: newChartType }, () => {\r\n      const { kwargs } = this.props.args;\r\n      const data = kwargs.data; // Assuming data is stored in kwargs.data\r\n      const formattedData = data.map((item) => ({\r\n        x: new Date(item.timestamp_est),\r\n        y: [item.open, item.high, item.low, item.close],\r\n      }));\r\n      this.chart.options.data[0].type = newChartType;\r\n      this.chart.options.data[0].dataPoints = formattedData;\r\n      this.chart.render();\r\n    });\r\n  }\r\n  async fetchGraphData() {\r\n    const { kwargs } = this.props.args\r\n    const { api } = kwargs\r\n    console.log(\"sdkhgfvbosdjk\",kwargs)\r\n    const res = await axios.post(api, { ...kwargs })\r\n    return JSON.parse(res.data)\r\n  }\r\n  async updateChart() {\r\n    const { kwargs } = this.props.args\r\n    const {\r\n      x_axis,\r\n      y_axis,\r\n      refresh_sec,\r\n      refresh_button,\r\n      theme_options,\r\n    } = kwargs\r\n    try {\r\n      const data = await this.fetchGraphData()\r\n      const newSeries = []\r\n      y_axis.map((axis, y_index) => {\r\n        return (newSeries[y_index] = data.map((row, index) => {\r\n          if (index === data.length - 1 && theme_options[\"showInLegendPerLine\"])\r\n            return {\r\n              x: row[x_axis[\"field\"]],\r\n              y: row[axis[\"field\"]],\r\n              indexLabel:\r\n                axis[\"name\"] +\r\n                \" \" +\r\n                row[axis[\"field\"]].toFixed(3) +\r\n                \"                        \\n.\",\r\n              indexLabelFontColor: axis[\"color\"],\r\n            }\r\n          else {\r\n            return {\r\n              x: row[x_axis[\"field\"]],\r\n              y: row[axis[\"field\"]],\r\n            }\r\n          }\r\n        }))\r\n      })\r\n\r\n      while (dataPoints[0].length) {\r\n        y_axis.map((item, index) => {\r\n          return dataPoints[index].pop()\r\n        })\r\n      }\r\n      console.log(\"fetchGraphData\", dataPoints)\r\n      y_axis.map((item, index) => {\r\n        dataPoints[index].push(...newSeries[index])\r\n        return this.chart.options.data[index].legendText = item[\"name\"] + newSeries[index].pop().y\r\n      })\r\n\r\n      const chartType = this.state.chartType;\r\n    if (chartType === \"spline\") {\r\n      this.chart.options.data.forEach((series, index) => {\r\n        series.type = \"spline\";\r\n        series.dataPoints = dataPoints[index];\r\n      });\r\n    } else if (chartType === \"candlestick\") {\r\n      const formattedData = data.map((item) => ({\r\n        x: new Date(item.timestamp_est),\r\n        y: [item.open, item.high, item.low, item.close],\r\n      }));\r\n      this.chart.options.data[0].type = \"candlestick\";\r\n      this.chart.options.data[0].dataPoints = formattedData;\r\n    }\r\n\r\n      this.chart.render()\r\n      refresh_button && !refresh_sec && toastr.success(`Success!`)\r\n    } catch (error) {\r\n      refresh_button &&\r\n        !refresh_sec &&\r\n        toastr.error(`Fetch Error: ${error.message}`)\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const colorSet = []\r\n    const { kwargs } = this.props.args\r\n    const { y_axis, y_max, refresh_sec, theme_options, refresh_button } =\r\n      kwargs\r\n    const dataY = y_axis.map((item, index) => {\r\n      colorSet.push(item[\"color\"])\r\n      return {\r\n        type: \"spline\",\r\n        xValueFormatString: \"#.##0 \",\r\n        yValueFormatString: \"#.##0\",\r\n        showInLegend: theme_options[\"showInLegend\"],\r\n        name: item[\"name\"],\r\n        dataPoints: dataPoints[index],\r\n        // lineColor: item['color'] ? item['color'] : ''\r\n      }\r\n    })\r\n    CanvasJS.addColorSet(\"greenShades\", colorSet)\r\n    const options = {\r\n      colorSet: \"greenShades\",\r\n      backgroundColor: theme_options[\"backgroundColor\"]\r\n        ? theme_options[\"backgroundColor\"]\r\n        : \"white\",\r\n      zoomEnabled: true,\r\n      title: {\r\n        text: theme_options[\"main_title\"] ? theme_options[\"main_title\"] : \"\",\r\n      },\r\n      axisX: {\r\n        title: theme_options[\"x_axis_title\"]\r\n          ? theme_options[\"x_axis_title\"]\r\n          : \"\",\r\n        labelFormatter: (e) => moment(e.value).format(\"DD/MM/YYYY hh\"),\r\n        labelFontSize: 12,\r\n      },\r\n      axisY: {\r\n        suffix: \"\",\r\n        maximum: y_max ? y_max : null,\r\n        gridColor: theme_options[\"grid_color\"]\r\n          ? theme_options[\"grid_color\"]\r\n          : \"\",\r\n      },\r\n      toolTip: {\r\n        shared: true,\r\n        contentFormatter: function (e) {\r\n            let content = \"\";\r\n    \r\n            // Format the x-axis time and add it to the tooltip content\r\n            const formattedXValue = moment(e.entries[0].dataPoint.x).format(\"DD/MM/YYYY HH:mm\");\r\n            content += `<strong>Date</strong>: ${formattedXValue}<br/>`;\r\n    \r\n            // Loop through other data points (excluding the x-axis time) and add them to the tooltip content\r\n            for (let i = 1; i < e.entries.length; i++) {\r\n                const entry = e.entries[i];\r\n                const dataSeries = entry.dataSeries;\r\n                const dataPoint = entry.dataPoint;\r\n                const color = dataSeries.color ? dataSeries.color : dataSeries.options.color;\r\n                content += `<strong style=\"color: ${color}\">${dataSeries.name}</strong>: ${dataPoint.y}<br/>`;\r\n            }\r\n    \r\n            return content;\r\n        }\r\n    },\r\n      legend: {\r\n        cursor: \"pointer\",\r\n        verticalAlign: \"top\",\r\n        fontSize: 18,\r\n        fontColor: \"dimGrey\",\r\n        itemclick: this.toggleDataSeries,\r\n      },\r\n      data: dataY,\r\n      height: kwargs.graph_height ? kwargs.graph_height : 400,\r\n    }\r\n    return (\r\n      <div>\r\n        {refresh_button && !refresh_sec && (\r\n          <div style={{ display: \"flex\" }}>\r\n            <div style={{ margin: \"10px 10px 10px 2px\" }}>\r\n              <button className=\"btn btn-warning\" onClick={this.updateChart}>\r\n                Refresh\r\n              </button>\r\n            </div>\r\n            <div style={{margin: \"10px 10px 10px 2px\"}}>\r\n              <button className=\"btn btn-warning\" onClick={this.toggleDataSeries}>\r\n                Toggle Chart\r\n              </button>\r\n            </div>\r\n          </div>\r\n        )}\r\n        <CanvasJSChart options={options} onRef={(ref) => (this.chart = ref)} />\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default withStreamlitConnection(App)\r\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport Main from \"./Main\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <Main />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}